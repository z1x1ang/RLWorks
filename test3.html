<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overleaf 中文版式</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* styles.css */
body {
    font-family: 'Noto Sans', sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f7f7f7;
    color: #333;
}

header {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    text-align: center;
}

h1 {
    margin: 0;
    font-size: 2em;
}

main {
    padding: 20px;
}

section {
    background-color: white;
    margin: 20px 0;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

h2 {
    margin-top: 0;
    color: #4CAF50;
}

p {
    line-height: 1.6;
}

footer {
    background-color: #4CAF50;
    color: white;
    text-align: center;
    padding: 10px 20px;
    position: fixed;
    bottom: 0;
    width: 100%;
}

@media (min-width: 600px) {
    main {
        max-width: 800px;
        margin: 0 auto;
    }
}

    </style>
</head>
<body>
    <header>
        <h1>Overleaf 中文版式</h1>
    </header>
    <main>
        <section>
            <h2>简介</h2>
            <p>这是一个使用HTML和CSS实现的Overleaf中文风格版式示例。</p>
        </section>
        <section>
            <h2>内容</h2>
            <p>在这里添加你的内容。</p>
        </section>
    </main>
    <footer>
        <p>&copy; 2024 你的名字</p>
    </footer>
</body>
</html>

使用更正式的数学符号和术语来描述上述的变异操作可以增加其表达的精确性。下面是更数学化的描述：

设有一个路径 \(\xi\)，其中 \(\xi\) 是一个节点序列，表示某个个体的路线。在差分进化的变异操作中，我们首先计算突变段的长度和起始位置：

1. **计算突变长度和起始索引**:
   \[
   L_{\text{mutation}} = \lfloor |\xi| \cdot r_{\text{mutation}} \rfloor
   \]
   \[
   i_{\text{start}} = \lfloor \text{random()} \cdot (|\xi| - L_{\text{mutation}}) \rfloor
   \]
   其中，\( |\xi| \) 是路径 \(\xi\) 的长度，\( r_{\text{mutation}} \) 是给定的突变率，\(\text{random()}\) 生成一个 [0,1) 范围内的随机数。

2. **确定突变段的结束索引**:
   \[
   i_{\text{end}} = \min(i_{\text{start}} + L_{\text{mutation}}, |\xi| - 1)
   \]

3. **生成突变段**:
   \[
   \xi_{\text{mutation}} = \text{MonteCarloPaths}(G, \xi[i_{\text{start}}], \xi[i_{\text{end}}], 1, L_{\text{mutation}} \times 4)
   \]
   这里，\(\xi[i_{\text{start}}]\) 和 \(\xi[i_{\text{end}}]\) 是突变段的起始和结束节点，\(G\) 是代表网格的图，\(\xi_{\text{mutation}}\) 是使用蒙特卡罗方法生成的新路径段。

4. **组合新路径**:
   \[
   \xi' = [\xi[0 : i_{\text{start}}-1], \xi_{\text{mutation}}, \xi[i_{\text{end}}+1 : |\xi|]]
   \]
   其中，\(\xi'\) 是变异后可能的新路径。

5. **检查新路径的合法性**:
   如果 \(\xi'\) 中包含重复的节点，则保留原始路径 \(\xi\)，否则采用新路径 \(\xi'\)。

这样的表述更加符合数学和计算机科学文献中的常规表达方式，更适合用于学术交流和论文写作。

### 老师的创新点
- 1.通过对数据集，状态-动作序列分析，可用社交网络中的网络分割和影响力节点的方法，给出 landmark 集合和与每个 landmark 有关系的状态团。
- 2.计算每个 landmark 之间和到各个目标的条件概率。
- 3.给出状态团中每个状态到与之相关的 landmark 的条件概率。
- 4.采用传统的强化学习框架训练得到一个客观的价值网络 

为了提升智能体动作产生轨迹的可读性，并将你已有的可读性计算方法融入上述系统，我们可以通过以下几个步骤来实现：

### 1. 定义可读性评分
首先，需要明确可读性评分的具体定义和计算方法。这个评分应该能够量化轨迹的清晰度、直观性或易理解性。例如，可读性评分可以基于以下因素：
- **动作的直观性**：简单、直接的动作序列得分更高。
- **状态的连贯性**：状态转换的逻辑性和连贯性。
-  **目标导向性**：轨迹是否有效地向目标前进，减少无关的循环或迂回。

### 2. 整合可读性评分到强化学习
将可读性评分作为奖励函数的一部分或作为训练智能体时的一个优化目标。具体步骤包括：
- **修改奖励函数**：在传统的强化学习奖励机制中，将可读性评分加入到奖励函数中。例如，每一步的奖励可以是传统的奖励加上该步骤的可读性评分。
- **多目标优化**：在训练过程中，不仅优化期望的累积奖励，还要优化轨迹的可读性。这可能需要采用多目标强化学习算法，或者调整算法以平衡这两种目标。

### 3. 利用网络分割和影响力节点
利用网络中的landmark和状态团来引导智能体产生更加可读的轨迹：
- **状态团的作用**：每个状态团可以定义为一个子目标或阶段，智能体在达到每个子目标时，都应该重新评估其轨迹的可读性。
- **landmark之间的路径优化**：在计算从一个landmark到另一个landmark的路径时，优先选择可读性高的路径。

### 4. 状态团到landmark的路径选择
为了增强整个轨迹的可读性，可以特别关注从状态团到landmark的路径选择：
- **条件概率与可读性的结合**：在选择下一步动作时，不仅考虑到达landmark的概率，还要考虑这一行动的可读性评分。

### 5. 训练和评估
- **训练**：使用修改后的奖励函数训练智能体，同时监控可读性和任务完成率的表现。
- **评估**：通过独立测试集评估智能体在未见过的网格世界中的表现，特别注意评估轨迹的可读性和效率。

通过这些步骤，你可以将可读性评分有效地融合到智能体的学习过程中，不仅提高智能体的任务执行效率，还增强了其行动轨迹的直观性和易理解性。这种方法特别适用于需要智能体与人类用户交互或协作的应用场景。