<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>论文相关实验</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!-- 引入与数学公式有关的库 -->
    <script>MathJax = {tex: {inlineMath: [['$', '$'],['$$', '$$'], ['\\(', '\\)']]}}</script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <link rel="stylesheet" type="text/css" href="style.css">
    <body>
    <header>
      <h2>强化学习论文相关实验</h2>
    </header>
    <section>
      <nav>
        <ul>
          <li><a href="#" onclick="showContent('test')">实验1</a></li>
          <li><a href="#">实验2</a></li>
          <li><a href="#">实验3</a></li>
        </ul>
      </nav>
      
      <article id="article-content">
        <h1>不同可读性的轨迹对智能体协作的影响</h1>
        <div class="row">
        <img id="gifImage" class="float-img" src="img/bukedu.gif" alt="图片加载中...">
        <p>
          如左图所示，蓝色智能体(观察者)观察黑色智能体的移动轨迹，进而通过贝叶斯公式判断智能体的的目标是 $g_1$ 还是$g_2$<br>
          \(
          P(g|\xi_{s_0 \rightarrow q}) = \frac{1}{z} \frac{\exp(-C(\xi_{s_0 \rightarrow q}) - C(\xi^*_{q \rightarrow g}))}{\exp(-C(\xi^*_{s_0 \rightarrow g}))} P(g)
        \)
       <br>
        <small>(公式具体推导详见Bied与Dragan的论文以及下方的计算链接)</small> <br>
        公式如上所示，由于已经过归一化处理，我们就设定: <br>
        $P(g_1|\xi_{s_0 \rightarrow q})>0.5$ 蓝色智能体相信黑色智能体去$g_1$(观察者外框颜色:黄色)<br>
        $P(g_1|\xi_{s_0 \rightarrow q})<0.5$ 蓝色智能体相信黑色智能体去$g_2$(观察者外框颜色:黑色)<br>
        $P(g_1|\xi_{s_0 \rightarrow q})=0.5$ 蓝色智能体则随机相信智能体的下一个目标(观察者外框颜色:白色)
        </p>
        <p>通过上述规则,智能体决定自己下一步的动作策略的选择(Qlearning训练完成收敛的策略)，觉得蓝色智能体要去哪里自己就去另一个目标。<br>
        左图的轨迹可读性并不是那么好，至少前五步，蓝色智能体还在随机确定目标，整体消耗的步数17步。</p>
      </div>
      <div style="clear: both;"></div> <!-- 清除浮动影响 -->  
      <div class="row">
        <img id="gifImage2" class="float-img" src="img/kedu.gif" alt="图片加载中...">
        <p>如左图所示，黑色智能体所走的总步数仍为7步,但整体可读性显然更好(<a href="https://raw.githubusercontent.com/z1x1ang/Legible/master/%E5%8F%AF%E8%AF%BB%E6%80%A7%E5%85%AC%E5%BC%8F%E8%AE%A1%E7%AE%97%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.jpg">具体计算过程</a>)，蓝色智能体从第一步一开始就对黑色智能体所要到达的目标充满信心，整体消耗步数15步。</p>
        <p>通过分析可知,可读性较好的动作轨迹，能够有效减少系统的成本消耗。但同样过于追求较高的可读性(绕路),反而也会增加系统总的成本消耗，所以必须要把可读性$\lambda$限制在一定的范围内，这个可以作为进一步的研究方向。
          \[
          P_i = \frac{f_i}{\sum_{j=1}^{N} f_j}
          \]
        </p>
      </div>
      </article>
    </section>
    <footer>
      <p>&copy; 2024</p>
    </footer>
    
    <script src="script.js"></script>
    </body>
</head>
</html>

使用更正式的数学符号和术语来描述上述的变异操作可以增加其表达的精确性。下面是更数学化的描述：

设有一个路径 \(\xi\)，其中 \(\xi\) 是一个节点序列，表示某个个体的路线。在差分进化的变异操作中，我们首先计算突变段的长度和起始位置：

1. **计算突变长度和起始索引**:
   \[
   L_{\text{mutation}} = \lfloor |\xi| \cdot r_{\text{mutation}} \rfloor
   \]
   \[
   i_{\text{start}} = \lfloor \text{random()} \cdot (|\xi| - L_{\text{mutation}}) \rfloor
   \]
   其中，\( |\xi| \) 是路径 \(\xi\) 的长度，\( r_{\text{mutation}} \) 是给定的突变率，\(\text{random()}\) 生成一个 [0,1) 范围内的随机数。

2. **确定突变段的结束索引**:
   \[
   i_{\text{end}} = \min(i_{\text{start}} + L_{\text{mutation}}, |\xi| - 1)
   \]

3. **生成突变段**:
   \[
   \xi_{\text{mutation}} = \text{MonteCarloPaths}(G, \xi[i_{\text{start}}], \xi[i_{\text{end}}], 1, L_{\text{mutation}} \times 4)
   \]
   这里，\(\xi[i_{\text{start}}]\) 和 \(\xi[i_{\text{end}}]\) 是突变段的起始和结束节点，\(G\) 是代表网格的图，\(\xi_{\text{mutation}}\) 是使用蒙特卡罗方法生成的新路径段。

4. **组合新路径**:
   \[
   \xi' = [\xi[0 : i_{\text{start}}-1], \xi_{\text{mutation}}, \xi[i_{\text{end}}+1 : |\xi|]]
   \]
   其中，\(\xi'\) 是变异后可能的新路径。

5. **检查新路径的合法性**:
   如果 \(\xi'\) 中包含重复的节点，则保留原始路径 \(\xi\)，否则采用新路径 \(\xi'\)。

这样的表述更加符合数学和计算机科学文献中的常规表达方式，更适合用于学术交流和论文写作。